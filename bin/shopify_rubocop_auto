#!/usr/bin/env ruby

require "digest"
require "optparse"

options = {}
OptionParser.new do |parser|
  parser.banner = "Usage: shopify_rubocop_auto [options] [paths]\nIf paths or violations are empty, all will be run."
  parser.on("--name NAME",  "Name for committer")
  parser.on("--email EMAIL",  "Email for committer")
  parser.on("--collaborator_name NAME",  "Name for collaborator")
  parser.on("--collaborator_email EMAIL",  "Email for collaborator")
  parser.on("--commits COMMITS",  "Count of commits to make")
  parser.on("--violations [VIOLATIONS]", "Names of the Rubocop violations, comma separated")

  if ARGV.empty?
    puts parser
    exit 1
  end
end.parse!(into: options)

paths = ARGV

class Runner
  def initialize(name:, email:, collaborator_name:, collaborator_email:, commits:, violations: nil, paths: nil)
    @committer_name = name
    @committer_email = email
    @collaborator_name = collaborator_name
    @collaborator_email = collaborator_email
    @commits = commits.to_i
    raise "Invalid number of commits" if @commits <= 0
    @violations = (violations || []).split(",").map(&:strip).reject(&:empty?)
    @violations = nil if @violations.empty?
    @paths = paths || []
  end

  def run!
    puts "Running with: #{@committer_name}, #{@committer_email}, #{@collaborator_name}, #{@collaborator_email}, #{@commits}, #{@violations}, #{@paths}"

    Cleaner.new(
      commits: @commits,
      violations: @violations,
      paths: @paths,
      individuals: [
        {
          email: @committer_email,
          name: @committer_name,
        },
        {
          email: @collaborator_email,
          name: @collaborator_name,
        },
      ]
    ).clean!
  end
end

class Cleaner
  FILE_PATH = ".rubocop_todo.yml"

  def initialize(commits:, violations: nil, paths:, individuals:)
    @commits = commits
    @violations = violations
    @individuals = individuals
    @paths = paths

    @id = Digest::MD5.hexdigest(Time.now.to_s)[0..5]
    @branch = "rubocop-auto-cleanup-#{@id}"

    @attempts = 0
    @successes = 0

    @files_processed = []
  end

  def clean!
    puts "Cleanup in process!"
    puts "ID: #{@id}"
    puts "Branch: #{@branch}"

    reset_env
    prepare_env

    while @successes < @commits
      @attempts += 1

      puts "Attempt ##{@attempts}"
      puts " - Successes: #{@successes}"
      filename = cleanup_something

      if filename.nil?
        if @successes > 1
          puts "No more candidates found. Exiting."
          break
        else
          raise "No candidates found. Exiting."
        end
      end

      if style_check
        puts "Success!"

        @successes += 1

        `git add .`

        commiter = @individuals.first

        message = "Rubocop auto-cleanup #{filename}"
        @individuals.each do |co_author|
          next if co_author.fetch(:email) == commiter.fetch(:email)

          message += "\n\nCo-authored-by: #{co_author.fetch(:name)} <#{co_author.fetch(:email)}>"
        end

        `git -c user.email=#{commiter.fetch(:email)} -c user.name="#{commiter.fetch(:name)}" commit -m "#{message}"`
      else
        `git reset --hard`
      end
    end

    `git push origin #{@branch} --no-verify`
    `git branch --set-upstream-to=origin/#{@branch} #{@branch}`
    `git pull`
    sleep 2
    `open https://github.com/Shopify/shopify/compare/#{@branch}?expand=1`
  end

  private

  def reset_env
    puts "Resetting environment..."
    `git reset --hard`
    `git checkout main`
    `git reset --hard origin/main`
    `git pull origin main`
  end

  def prepare_env
    `git checkout -b #{@branch}`
  end

  def get_candidates(lines)
    candidates = {}
    current_group = nil

    lines.each.with_index do |line, i|
      if match = line.match(/^(?<name>[\w\/]+):$/)
        current_group = match[:name]
        next
      end

      if @target_violations.length > 0 && !@target_violations.include?(current_group)
        next
      end

      next unless line.start_with?("    - '")

      filename = line[/[\w\/.]+/]
      next if @files_processed.include?(filename)

      if @paths.length > 0
        if @paths.any? { |path| line.match?(Regexp.new(path)) }
          candidates[i] = filename
        end
      else
        candidates[i] = filename
      end
    end

    candidates
  end

  def cleanup_something
    lines = File.readlines(FILE_PATH)

    candidates = get_candidates(lines)
    puts " - Candidates remaining: #{candidates.keys.length}"

    target_index = candidates.keys.sample

    return if target_index.nil?

    target_file = candidates[target_index]

    @files_processed << target_file

    output_lines = lines.reject.with_index do |line, i|
      target_index == i
    end

    File.open(FILE_PATH, "w") do |f|
      output_lines.each do |line|
        f.write(line)
      end
    end

    target_file
  end

  def style_check
    system("bin/style")
  end
end

Runner.new(**options).run!
